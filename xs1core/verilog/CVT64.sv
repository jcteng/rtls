// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module CVT64(
  input         clock,
  input         reset,
  input         io_fire,
  input  [63:0] io_src,
  input  [7:0]  io_opType,
  input  [2:0]  io_rm,
  input  [3:0]  io_input1H,
  input  [3:0]  io_output1H,
  input         io_isFpToVecInst,
  output [63:0] io_result,
  output [4:0]  io_fflags
);

  wire [6:0]   _rec7Table_out;
  wire [6:0]   _rsqrt7Table_out;
  wire         _subRounder_io_inexact;
  wire         _subRounder_io_r_up;
  wire         _rounder_io_inexact;
  wire         _rounder_io_r_up;
  wire [64:0]  _shiftRightJam_io_out;
  wire         _shiftRightJam_io_sticky;
  wire [6:0]   _leadZerosNext_clz_io_out;
  reg          fireReg_last_r;
  reg          s1_outIsF64;
  reg          s1_outIsU32;
  reg          s1_outIsS32;
  reg          s1_outIsU64;
  reg          s1_outIsS64;
  reg          s1_fpCanonicalNAN;
  reg          s2_outIsF64;
  reg          s2_fpCanonicalNAN;
  wire [64:0]  input_0 =
    io_opType[7]
      ? (io_input1H[1] ? {io_src[15], 6'h0, io_src[14:0], 43'h0} : 65'h0)
        | (io_input1H[2] ? {io_src[31], 3'h0, io_src[30:0], 30'h0} : 65'h0)
        | (io_input1H[3] ? {io_src, 1'h0} : 65'h0)
      : (io_input1H[0] ? {{57{io_opType[0] & io_src[7]}}, io_src[7:0]} : 65'h0)
        | (io_input1H[1] ? {{49{io_opType[0] & io_src[15]}}, io_src[15:0]} : 65'h0)
        | (io_input1H[2] ? {{33{io_opType[0] & io_src[31]}}, io_src[31:0]} : 65'h0)
        | (io_input1H[3] ? {io_opType[0] & io_src[63], io_src} : 65'h0);
  wire [63:0]  absIntSrcNext =
    input_0[64] ? 64'(~(input_0[63:0]) + 64'h1) : input_0[63:0];
  wire [2:0]   decodeFloatSrc =
    (io_input1H[1] ? {|(input_0[52:43]), &(input_0[57:53]), |(input_0[57:53])} : 3'h0)
    | (io_input1H[2] ? {|(input_0[52:30]), &(input_0[60:53]), |(input_0[60:53])} : 3'h0)
    | (io_input1H[3] ? {|(input_0[52:1]), &(input_0[63:53]), |(input_0[63:53])} : 3'h0);
  wire         isSubnormalSrcNext = ~(decodeFloatSrc[0]) & decodeFloatSrc[2];
  wire         isRecNext = io_opType[5] & io_opType[0];
  wire         _GEN = io_opType[7] & io_opType[6];
  wire         isFpWidenNext = _GEN & ~(io_opType[4]) & io_opType[3];
  wire         isFpNarrowNext = _GEN & io_opType[4] & ~(io_opType[3]);
  reg          expIsOnesSrc;
  reg          fracNotZeroSrc;
  reg          isSubnormalSrc;
  reg          isnormalSrc;
  reg          isInfSrc;
  reg          isZeroSrc;
  reg          isNaNSrc;
  reg          isSNaNSrc;
  reg          isQNaNSrc;
  reg          isNormalRec0;
  reg          isNormalRec1;
  reg          isNormalRec2;
  reg          isSubnormalRec0;
  reg          isSubnormalRec1;
  reg          isSubnormalRec2;
  reg          isRec;
  reg          isInt2Fp;
  reg          isFpWiden;
  reg          isFpNarrow;
  reg          isEstimate7;
  reg          isFp2Int;
  reg          trunSticky;
  reg          signSrc;
  reg  [2:0]   rm;
  reg          hasSignInt;
  reg          isZeroIntSrc;
  reg  [3:0]   output1HReg;
  reg  [4:0]   fflags;
  reg  [63:0]  result;
  wire [63:0]  fracSrcLeftNext = {input_0[52:1], 12'h0};
  reg  [12:0]  expAdderIn0;
  reg  [12:0]  expAdderIn1;
  reg          expNormaled0;
  reg          inIsFp;
  reg  [63:0]  fracSrcLeft;
  reg  [63:0]  absIntSrc;
  reg  [6:0]   leadZeros;
  wire [191:0] _shiftLeft_T_2 =
    {127'h0, inIsFp ? fracSrcLeft : absIntSrc, 1'h0} << leadZeros;
  wire [51:0]  fracNormaled = isSubnormalSrc ? _shiftLeft_T_2[63:12] : fracSrcLeft[63:12];
  reg  [64:0]  shamtIn;
  reg  [10:0]  shamt;
  wire [63:0]  rounderMapIn = isFpNarrow ? fracSrcLeft : _shiftLeft_T_2[63:0];
  wire [63:0]  rounderInput =
    isFp2Int
      ? _shiftRightJam_io_out[64:1]
      : {12'h0,
         {29'h0,
          {13'h0, output1HReg[1] ? rounderMapIn[63:54] : 10'h0}
            | (output1HReg[2] ? rounderMapIn[63:41] : 23'h0)}
           | (output1HReg[3] ? rounderMapIn[63:12] : 52'h0)};
  wire         _subRounderMap_T_9 = trunSticky | _shiftRightJam_io_sticky;
  wire [22:0]  subRounderInput =
    {13'h0, output1HReg[1] ? _shiftRightJam_io_out[63:54] : 10'h0}
    | (output1HReg[2] ? _shiftRightJam_io_out[63:41] : 23'h0);
  reg  [63:0]  s2_resultForfpCanonicalNAN;
  wire         isNaNSrcNext = decodeFloatSrc[1] & decodeFloatSrc[2];
  wire [1:0]   decodeFloatSrcRec =
    (io_input1H[1]
       ? {(&(input_0[57:55])) & ~(input_0[54]) & input_0[53],
          (&(input_0[57:54])) & ~(input_0[53])}
       : 2'h0)
    | (io_input1H[2]
         ? {(&(input_0[60:55])) & ~(input_0[54]) & input_0[53],
            (&(input_0[60:54])) & ~(input_0[53])}
         : 2'h0)
    | (io_input1H[3]
         ? {(&(input_0[63:55])) & ~(input_0[54]) & input_0[53],
            (&(input_0[63:54])) & ~(input_0[53])}
         : 2'h0);
  wire         signNonNan = ~isNaNSrc & signSrc;
  wire [12:0]  _exp_T = 13'(expAdderIn0 + expAdderIn1);
  wire         cout =
    _rounder_io_r_up
    & (isFp2Int
         ? output1HReg[0] & ~hasSignInt & (&(rounderInput[7:0])) | output1HReg[0]
           & hasSignInt & (&(rounderInput[6:0])) | output1HReg[1] & ~hasSignInt
           & (&(rounderInput[15:0])) | output1HReg[1] & hasSignInt
           & (&(rounderInput[14:0])) | output1HReg[2] & ~hasSignInt
           & (&(rounderInput[31:0])) | output1HReg[2] & hasSignInt
           & (&(rounderInput[30:0])) | output1HReg[3] & ~hasSignInt & (&rounderInput)
           | output1HReg[3] & hasSignInt & (&(rounderInput[62:0]))
         : output1HReg[1] & (&(rounderMapIn[63:54])) | output1HReg[2]
           & (&(rounderMapIn[63:41])) | output1HReg[3] & (&(rounderMapIn[63:12])));
  wire [10:0]  _expRounded_T = cout ? 11'(_exp_T[10:0] + 11'h1) : _exp_T[10:0];
  wire [63:0]  fracRounded = _rounder_io_r_up ? 64'(rounderInput + 64'h1) : rounderInput;
  wire         rmin = rm == 3'h1 | signSrc & rm == 3'h3 | ~signSrc & rm == 3'h2;
  wire         ofRounded =
    ~(_exp_T[12])
    & (output1HReg[1]
       & (cout
            ? (&(_exp_T[4:1])) | (|(_exp_T[11:5]))
            : (&(_exp_T[4:0])) | (|(_exp_T[11:5]))) | output1HReg[2]
       & (cout
            ? (&(_exp_T[7:1])) | (|(_exp_T[11:8]))
            : (&(_exp_T[7:0])) | (|(_exp_T[11:8]))) | output1HReg[3]
       & (cout ? (&(_exp_T[10:1])) | _exp_T[11] : (&(_exp_T[10:0])) | _exp_T[11]));
  wire         _result1H_T = ofRounded & rmin;
  wire         _result1H_T_2 = ofRounded & ~rmin;
  wire         _result1H_T_5 = ~ofRounded & ~isZeroIntSrc;
  wire         _result1H_T_6 = isSubnormalSrc | isnormalSrc;
  wire         ofRounded_1 =
    ~(_exp_T[12])
    & (output1HReg[1]
       & (cout
            ? (&(_exp_T[4:1])) | (|(_exp_T[11:5]))
            : (&(_exp_T[4:0])) | (|(_exp_T[11:5]))) | output1HReg[2]
       & (cout
            ? (&(_exp_T[7:1])) | (|(_exp_T[11:8]))
            : (&(_exp_T[7:0])) | (|(_exp_T[11:8]))) | output1HReg[3]
       & (cout ? (&(_exp_T[10:1])) | _exp_T[11] : (&(_exp_T[10:0])) | _exp_T[11]));
  wire         maybeSub = _exp_T[12] | ~(|_exp_T);
  wire [22:0]  subFracRounded =
    _subRounder_io_r_up ? 23'(subRounderInput + 23'h1) : subRounderInput;
  wire         subCout =
    _subRounder_io_r_up
    & (output1HReg[1] & (&(_shiftRightJam_io_out[63:54])) | output1HReg[2]
       & (&(_shiftRightJam_io_out[63:41])));
  wire         _result1H_T_18 = rm == 3'h6;
  wire         _result1H_T_13 =
    ~expIsOnesSrc & ~maybeSub & ofRounded_1 & (rmin | _result1H_T_18);
  wire         _result1H_T_21 =
    ~expIsOnesSrc & ~maybeSub & ofRounded_1 & ~(rmin | _result1H_T_18);
  wire         _result1H_T_26 = ~expIsOnesSrc & ~maybeSub & ~ofRounded_1;
  wire         _result1H_T_28 = ~expIsOnesSrc & maybeSub;
  wire [6:0]   fracEstimate = isRec ? _rec7Table_out : _rsqrt7Table_out;
  wire         _recResult1H_T_2 = isZeroSrc | isSubnormalRec2 & ~rmin;
  wire         _recResult1H_T_4 = isNormalRec2 | isSubnormalRec0 | isSubnormalRec1;
  wire         _recResult1H_T_5 = isSubnormalRec2 & rmin;
  wire         _sqrtResult1H_T_2 = signSrc & ~isZeroSrc | isNaNSrc;
  wire         _sqrtResult1H_T_7 = ~signSrc & ~isZeroSrc & ~expIsOnesSrc;
  wire [1:0]   _GEN_0 = {hasSignInt, cout};
  wire         ofExpRounded =
    ~(_exp_T[12])
    & (output1HReg[0]
       & (_GEN_0 == 2'h0 & (|(_exp_T[11:3])) | _GEN_0 == 2'h1
          & ((|(_exp_T[11:3])) | (&(_exp_T[2:0]))) | _GEN_0 == 2'h2
          & ((|(_exp_T[11:3])) | (&(_exp_T[2:0]))) | (&_GEN_0)
          & ((|(_exp_T[11:3])) | (&(_exp_T[2:1])))) | output1HReg[1]
       & (_GEN_0 == 2'h0 & (|(_exp_T[11:4])) | _GEN_0 == 2'h1
          & ((|(_exp_T[11:4])) | (&(_exp_T[3:0]))) | _GEN_0 == 2'h2
          & ((|(_exp_T[11:4])) | (&(_exp_T[3:0]))) | (&_GEN_0)
          & ((|(_exp_T[11:4])) | (&(_exp_T[3:1])))) | output1HReg[2]
       & (_GEN_0 == 2'h0 & (|(_exp_T[11:5])) | _GEN_0 == 2'h1
          & ((|(_exp_T[11:5])) | (&(_exp_T[4:0]))) | _GEN_0 == 2'h2
          & ((|(_exp_T[11:5])) | (&(_exp_T[4:0]))) | (&_GEN_0)
          & ((|(_exp_T[11:5])) | (&(_exp_T[4:1])))) | output1HReg[3]
       & (_GEN_0 == 2'h0 & (|(_exp_T[11:6])) | _GEN_0 == 2'h1
          & ((|(_exp_T[11:6])) | (&(_exp_T[5:0]))) | _GEN_0 == 2'h2
          & ((|(_exp_T[11:6])) | (&(_exp_T[5:0]))) | (&_GEN_0)
          & ((|(_exp_T[11:6])) | (&(_exp_T[5:1])))));
  wire         toUnv =
    ofExpRounded | expIsOnesSrc | signSrc
    & ~(isZeroSrc | ~(|fracRounded) & ~ofExpRounded);
  wire         toInv =
    ofExpRounded
    & ~(signSrc
        & (output1HReg[0] & _exp_T[12:3] == 10'h0
           & (cout ? (&(_exp_T[2:1])) & ~(_exp_T[0]) : (&(_exp_T[2:0]))) | output1HReg[1]
           & _exp_T[12:4] == 9'h0
           & (cout ? (&(_exp_T[3:1])) & ~(_exp_T[0]) : (&(_exp_T[3:0]))) | output1HReg[2]
           & _exp_T[12:5] == 8'h0
           & (cout ? (&(_exp_T[4:1])) & ~(_exp_T[0]) : (&(_exp_T[4:0]))) | output1HReg[3]
           & _exp_T[12:6] == 7'h0
           & (cout ? (&(_exp_T[5:1])) & ~(_exp_T[0]) : (&(_exp_T[5:0]))))
        & (output1HReg[0] & fracRounded[7] & fracRounded[6:0] == 7'h0 | output1HReg[1]
           & fracRounded[15] & fracRounded[14:0] == 15'h0 | output1HReg[2]
           & fracRounded[31] & fracRounded[30:0] == 31'h0 | output1HReg[3]
           & fracRounded[63] & fracRounded[62:0] == 63'h0)) | expIsOnesSrc;
  wire         of =
    isInt2Fp
      ? ofRounded
      : ~isFpWiden
        & (isFpNarrow
             ? ~expIsOnesSrc & ofRounded_1
             : isEstimate7 & isRec & isSubnormalRec2);
  wire [63:0]  _GEN_1 =
    isFpNarrow
      ? {32'h0,
         {16'h0,
          output1HReg[1]
            ? (expIsOnesSrc ? {signNonNan, 5'h1F, fracNotZeroSrc, 9'h0} : 16'h0)
              | (_result1H_T_13 ? {signNonNan, 15'h7BFF} : 16'h0)
              | (_result1H_T_21 ? {signNonNan, 15'h7C00} : 16'h0)
              | (_result1H_T_26
                   ? {signNonNan, _expRounded_T[4:0], fracRounded[9:0]}
                   : 16'h0)
              | (_result1H_T_28
                   ? {signNonNan, 4'h0, subCout, subFracRounded[9:0]}
                   : 16'h0)
            : 16'h0}
           | (output1HReg[2]
                ? (expIsOnesSrc ? {signNonNan, 8'hFF, fracNotZeroSrc, 22'h0} : 32'h0)
                  | (_result1H_T_13 ? {signNonNan, 31'h7F7FFFFF} : 32'h0)
                  | (_result1H_T_21 ? {signNonNan, 31'h7F800000} : 32'h0)
                  | (_result1H_T_26
                       ? {signNonNan, _expRounded_T[7:0], fracRounded[22:0]}
                       : 32'h0)
                  | (_result1H_T_28 ? {signNonNan, 7'h0, subCout, subFracRounded} : 32'h0)
                : 32'h0)}
      : isEstimate7
          ? (isRec
               ? {32'h0,
                  {16'h0,
                   output1HReg[1]
                     ? (isNaNSrc ? 16'h7E00 : 16'h0)
                       | (isInfSrc ? {signSrc, 15'h0} : 16'h0)
                       | (_recResult1H_T_2 ? {signSrc, 15'h7C00} : 16'h0)
                       | (isNormalRec0 ? {signSrc, 7'h1, fracEstimate, 1'h0} : 16'h0)
                       | (isNormalRec1 ? {signSrc, 6'h1, fracEstimate, 2'h0} : 16'h0)
                       | (_recResult1H_T_4
                            ? {signSrc, _exp_T[4:0], fracEstimate, 3'h0}
                            : 16'h0) | (_recResult1H_T_5 ? {signSrc, 15'h7BFF} : 16'h0)
                     : 16'h0}
                    | (output1HReg[2]
                         ? (isNaNSrc ? 32'h7FC00000 : 32'h0)
                           | (isInfSrc ? {signSrc, 31'h0} : 32'h0)
                           | (_recResult1H_T_2 ? {signSrc, 31'h7F800000} : 32'h0)
                           | (isNormalRec0
                                ? {signSrc, 10'h1, fracEstimate, 14'h0}
                                : 32'h0)
                           | (isNormalRec1 ? {signSrc, 9'h1, fracEstimate, 15'h0} : 32'h0)
                           | (_recResult1H_T_4
                                ? {signSrc, _exp_T[7:0], fracEstimate, 16'h0}
                                : 32'h0)
                           | (_recResult1H_T_5 ? {signSrc, 31'h7F7FFFFF} : 32'h0)
                         : 32'h0)}
                 | (output1HReg[3]
                      ? (isNaNSrc ? 64'h7FF8000000000000 : 64'h0)
                        | (isInfSrc ? {signSrc, 63'h0} : 64'h0)
                        | (_recResult1H_T_2 ? {signSrc, 63'h7FF0000000000000} : 64'h0)
                        | (isNormalRec0 ? {signSrc, 13'h1, fracEstimate, 43'h0} : 64'h0)
                        | (isNormalRec1 ? {signSrc, 12'h1, fracEstimate, 44'h0} : 64'h0)
                        | (_recResult1H_T_4
                             ? {signSrc, _exp_T[10:0], fracEstimate, 45'h0}
                             : 64'h0)
                        | (_recResult1H_T_5 ? {signSrc, 63'h7FEFFFFFFFFFFFFF} : 64'h0)
                      : 64'h0)
               : {32'h0,
                  {16'h0,
                   output1HReg[1]
                     ? (_sqrtResult1H_T_2 ? 16'h7E00 : 16'h0)
                       | (isZeroSrc ? {signSrc, 15'h7C00} : 16'h0)
                       | (_sqrtResult1H_T_7
                            ? {signSrc, _exp_T[5:1], fracEstimate, 3'h0}
                            : 16'h0)
                     : 16'h0}
                    | (output1HReg[2]
                         ? (_sqrtResult1H_T_2 ? 32'h7FC00000 : 32'h0)
                           | (isZeroSrc ? {signSrc, 31'h7F800000} : 32'h0)
                           | (_sqrtResult1H_T_7
                                ? {signSrc, _exp_T[8:1], fracEstimate, 16'h0}
                                : 32'h0)
                         : 32'h0)}
                 | (output1HReg[3]
                      ? (_sqrtResult1H_T_2 ? 64'h7FF8000000000000 : 64'h0)
                        | (isZeroSrc ? {signSrc, 63'h7FF0000000000000} : 64'h0)
                        | (_sqrtResult1H_T_7
                             ? {signSrc, _exp_T[11:1], fracEstimate, 45'h0}
                             : 64'h0)
                      : 64'h0))
          : (~hasSignInt & ~toUnv | hasSignInt & ~toInv
               ? (signSrc & (|fracRounded) ? 64'(~fracRounded + 64'h1) : fracRounded)
               : 64'h0)
            | {64{~hasSignInt & toUnv
                    & (isNaNSrc | ~signSrc & (isInfSrc | ofExpRounded))}}
            | (hasSignInt & toInv
                 ? {32'h0,
                    {16'h0,
                     {8'h0, output1HReg[0] ? {signNonNan, {7{~signNonNan}}} : 8'h0}
                       | (output1HReg[1] ? {signNonNan, {15{~signNonNan}}} : 16'h0)}
                      | (output1HReg[2] ? {signNonNan, {31{~signNonNan}}} : 32'h0)}
                   | (output1HReg[3] ? {signNonNan, {63{~signNonNan}}} : 64'h0)
                 : 64'h0);
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      fireReg_last_r <= 1'h0;
      expIsOnesSrc <= 1'h0;
      fracNotZeroSrc <= 1'h0;
      isSubnormalSrc <= 1'h0;
      isnormalSrc <= 1'h0;
      isInfSrc <= 1'h0;
      isZeroSrc <= 1'h0;
      isNaNSrc <= 1'h0;
      isSNaNSrc <= 1'h0;
      isQNaNSrc <= 1'h0;
      isNormalRec0 <= 1'h0;
      isNormalRec1 <= 1'h0;
      isNormalRec2 <= 1'h0;
      isSubnormalRec0 <= 1'h0;
      isSubnormalRec1 <= 1'h0;
      isSubnormalRec2 <= 1'h0;
      isRec <= 1'h0;
      isInt2Fp <= 1'h0;
      isFpWiden <= 1'h0;
      isFpNarrow <= 1'h0;
      isEstimate7 <= 1'h0;
      isFp2Int <= 1'h0;
      trunSticky <= 1'h0;
      signSrc <= 1'h0;
      rm <= 3'h0;
      hasSignInt <= 1'h0;
      isZeroIntSrc <= 1'h0;
      output1HReg <= 4'h0;
      fflags <= 5'h0;
      result <= 64'h0;
      expNormaled0 <= 1'h0;
      inIsFp <= 1'h0;
      fracSrcLeft <= 64'h0;
    end
    else begin
      if (io_fire | fireReg_last_r)
        fireReg_last_r <= io_fire;
      if (io_fire) begin
        expIsOnesSrc <= decodeFloatSrc[1];
        fracNotZeroSrc <= decodeFloatSrc[2];
        isSubnormalSrc <= isSubnormalSrcNext;
        isnormalSrc <= ~(decodeFloatSrc[1]) & decodeFloatSrc[0];
        isInfSrc <= decodeFloatSrc[1] & ~(decodeFloatSrc[2]);
        isZeroSrc <= ~(decodeFloatSrc[0]) & ~(decodeFloatSrc[2]);
        isNaNSrc <= isNaNSrcNext;
        isSNaNSrc <= isNaNSrcNext & ~(input_0[52]);
        isQNaNSrc <= isNaNSrcNext & input_0[52];
        isNormalRec0 <= decodeFloatSrcRec[0];
        isNormalRec1 <= decodeFloatSrcRec[1];
        isNormalRec2 <=
          decodeFloatSrc[0] & ~(decodeFloatSrc[1]) & ~(decodeFloatSrcRec[0])
          & ~(decodeFloatSrcRec[1]);
        isSubnormalRec0 <= isSubnormalSrcNext & input_0[52];
        isSubnormalRec1 <= isSubnormalSrcNext & ~(input_0[52]) & input_0[51];
        isSubnormalRec2 <= isSubnormalSrcNext & input_0[52:51] == 2'h0;
        isRec <= isRecNext;
        isInt2Fp <= ~(io_opType[7]);
        isFpWiden <= isFpWidenNext;
        isFpNarrow <= isFpNarrowNext;
        isEstimate7 <= io_opType[5];
        isFp2Int <= ~(io_opType[6]);
        trunSticky <= |(input_0[29:1]);
        signSrc <= input_0[64];
        rm <= io_rm;
        hasSignInt <= io_opType[0];
        isZeroIntSrc <= absIntSrcNext == 64'h0;
        output1HReg <= io_output1H;
        expNormaled0 <= isSubnormalSrcNext ? _leadZerosNext_clz_io_out[0] : input_0[53];
        inIsFp <= io_opType[7];
        fracSrcLeft <= fracSrcLeftNext;
      end
      if (fireReg_last_r) begin
        fflags <=
          {~isInt2Fp
             & (isFpWiden
                  ? isSNaNSrc & ~s1_fpCanonicalNAN
                  : isFpNarrow
                      ? isSNaNSrc
                      : isEstimate7
                          ? ~isRec & signSrc & ~isZeroSrc & ~isQNaNSrc | isSNaNSrc
                          : hasSignInt ? toInv : toUnv),
           ~(isInt2Fp | isFpWiden | isFpNarrow) & isEstimate7 & isZeroSrc,
           of,
           ~(isInt2Fp | isFpWiden) & isFpNarrow & ~expIsOnesSrc & maybeSub
             & (~cout & ~(|_exp_T) | _exp_T[12]) & _subRounder_io_inexact,
           isInt2Fp
             ? ofRounded | _rounder_io_inexact
             : ~isFpWiden
               & (isFpNarrow
                    ? ~expIsOnesSrc
                      & (~maybeSub & (_rounder_io_inexact | ofRounded_1) | maybeSub
                         & _subRounder_io_inexact)
                    : isEstimate7
                        ? of
                        : hasSignInt
                            ? ~toInv & _rounder_io_inexact
                            : ~toUnv & _rounder_io_inexact)};
        result <=
          isInt2Fp
            ? {32'h0,
               {16'h0,
                output1HReg[1]
                  ? (_result1H_T ? {signSrc, 15'h7BFF} : 16'h0)
                    | (_result1H_T_2 ? {signSrc, 15'h7C00} : 16'h0)
                    | (isZeroIntSrc ? {signSrc, 15'h0} : 16'h0)
                    | (_result1H_T_5
                         ? {signSrc, _expRounded_T[4:0], fracRounded[9:0]}
                         : 16'h0)
                  : 16'h0}
                 | (output1HReg[2]
                      ? (_result1H_T ? {signSrc, 31'h7F7FFFFF} : 32'h0)
                        | (_result1H_T_2 ? {signSrc, 31'h7F800000} : 32'h0)
                        | (isZeroIntSrc ? {signSrc, 31'h0} : 32'h0)
                        | (_result1H_T_5
                             ? {signSrc, _expRounded_T[7:0], fracRounded[22:0]}
                             : 32'h0)
                      : 32'h0)}
              | (output1HReg[3]
                   ? (_result1H_T ? {signSrc, 63'h7FEFFFFFFFFFFFFF} : 64'h0)
                     | (_result1H_T_2 ? {signSrc, 63'h7FF0000000000000} : 64'h0)
                     | (isZeroIntSrc ? {signSrc, 63'h0} : 64'h0)
                     | (_result1H_T_5
                          ? {signSrc, _expRounded_T, fracRounded[51:0]}
                          : 64'h0)
                   : 64'h0)
            : isFpWiden
                ? {32'h0,
                   output1HReg[2]
                     ? (expIsOnesSrc ? {signNonNan, 8'hFF, fracNotZeroSrc, 22'h0} : 32'h0)
                       | (isZeroSrc ? {signNonNan, 31'h0} : 32'h0)
                       | (_result1H_T_6
                            ? {signNonNan, _exp_T[7:0], fracNormaled[51:29]}
                            : 32'h0)
                     : 32'h0}
                  | (output1HReg[3]
                       ? (expIsOnesSrc
                            ? {signNonNan, 11'h7FF, fracNotZeroSrc, 51'h0}
                            : 64'h0) | (isZeroSrc ? {signNonNan, 63'h0} : 64'h0)
                         | (_result1H_T_6
                              ? {signNonNan, _exp_T[10:0], fracNormaled}
                              : 64'h0)
                       : 64'h0)
                : _GEN_1;
      end
    end
  end // always @(posedge, posedge)
  wire [10:0]  _minusExp_T_11 =
    {1'h0,
     {3'h0, ~(io_opType[7]) | isFpWidenNext ? _leadZerosNext_clz_io_out : 7'h0}
       | (isFpNarrowNext
            ? {3'h0, io_output1H[1] ? 7'h70 : 7'h0} | (io_output1H[2] ? 10'h380 : 10'h0)
            : 10'h0)} | (io_opType[5] ? input_0[63:53] : 11'h0);
  wire [11:0]  _minusExp_T_15 =
    12'({1'h1,
         ~(_minusExp_T_11[10]),
         ~(_minusExp_T_11[9:0]
           | (io_opType[6]
                ? 10'h0
                : {3'h0, {3'h0, {4{io_input1H[1]}}} | {7{io_input1H[2]}}}
                  | {10{io_input1H[3]}}))} + 12'h1);
  wire [12:0]  minusExp = {_minusExp_T_15[11], _minusExp_T_15};
  wire [11:0]  _expAdderIn0Next_T_29 = {1'h0, input_0[63:53]};
  wire [10:0]  _expAdderIn0Next_T_31 =
    io_opType[7]
      ? 11'h0
      : {3'h0, {1'h0, io_output1H[1] ? 7'h4E : 7'h0} | (io_output1H[2] ? 8'hBE : 8'h0)}
        | (io_output1H[3] ? 11'h43E : 11'h0);
  wire [10:0]  _shamtWidth_T_16 =
    11'((io_opType[6]
           ? {1'h0,
              {3'h0, io_output1H[1] ? 7'h71 : 7'h0} | (io_output1H[2] ? 10'h381 : 10'h0)}
           : {3'h0, {1'h0, io_input1H[1] ? 7'h4E : 7'h0} | (io_input1H[2] ? 8'hBE : 8'h0)}
             | (io_input1H[3] ? 11'h43E : 11'h0)) - input_0[63:53]);
  wire [63:0]  _s1_resultForfpCanonicalNAN_T_13 =
    {1'h0,
     s1_outIsF64 ? 31'h7FF80000 : 31'h0,
     s1_outIsU32,
     {31{s1_outIsU32}} | {31{s1_outIsS32}}} | {64{s1_outIsU64}};
  always @(posedge clock) begin
    if (io_fire) begin
      s1_outIsF64 <= io_opType[6] & io_output1H[3];
      s1_outIsU32 <= ~(io_opType[6]) & io_output1H[2] & ~(io_opType[0]);
      s1_outIsS32 <= ~(io_opType[6]) & io_output1H[2] & io_opType[0];
      s1_outIsU64 <= ~(io_opType[6]) & io_output1H[3] & ~(io_opType[0]);
      s1_outIsS64 <= ~(io_opType[6]) & io_output1H[3] & io_opType[0];
      s1_fpCanonicalNAN <=
        io_isFpToVecInst & io_opType[7]
        & (io_input1H[1] & io_src[63:16] != 48'hFFFFFFFFFFFF | io_input1H[2]
           & io_src[63:32] != 32'hFFFFFFFF);
      expAdderIn0 <=
        {1'h0,
         {1'h0,
          _expAdderIn0Next_T_31[10],
          _expAdderIn0Next_T_31[9:0]
            | (isFpWidenNext
                 ? {3'h0, io_output1H[2] ? 7'h70 : 7'h0}
                   | (io_output1H[3] ? 10'h380 : 10'h0)
                 : 10'h0)}
           | (isFpNarrowNext
                ? (isSubnormalSrcNext ? 12'h1 : _expAdderIn0Next_T_29)
                : 12'h0)
           | (io_opType[5]
                ? {3'h0,
                   {3'h0, io_output1H[1] ? (isRecNext ? 6'h1D : 6'h2C) : 6'h0}
                     | (io_output1H[2] ? (isRecNext ? 9'hFD : 9'h17C) : 9'h0)}
                  | (io_output1H[3] ? (isRecNext ? 12'h7FD : 12'hBFC) : 12'h0)
                : 12'h0)
           | (io_opType[6] ? 12'h0 : isSubnormalSrcNext ? 12'h1 : _expAdderIn0Next_T_29)};
      expAdderIn1 <=
        (~(io_opType[7]) | isFpNarrowNext | ~(io_opType[6]) ? minusExp : 13'h0)
        | (isFpWidenNext
             ? (isSubnormalSrcNext ? minusExp : {2'h0, input_0[63:53]})
             : 13'h0)
        | (io_opType[5]
             ? (isSubnormalSrcNext ? {6'h0, _leadZerosNext_clz_io_out} : minusExp)
             : 13'h0);
      absIntSrc <= absIntSrcNext;
      leadZeros <= _leadZerosNext_clz_io_out;
      shamtIn <= {decodeFloatSrc[0] & ~(decodeFloatSrc[1]), input_0[52:1], 12'h0};
      shamt <= _shamtWidth_T_16 > 11'h40 ? 11'h41 : _shamtWidth_T_16;
    end
    if (fireReg_last_r) begin
      s2_outIsF64 <= s1_outIsF64;
      s2_fpCanonicalNAN <= s1_fpCanonicalNAN;
      s2_resultForfpCanonicalNAN <=
        {_s1_resultForfpCanonicalNAN_T_13[63],
         _s1_resultForfpCanonicalNAN_T_13[62:0] | {63{s1_outIsS64}}};
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:13];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'hE; i += 4'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        fireReg_last_r = _RANDOM[4'h0][0];
        s1_outIsF64 = _RANDOM[4'h0][1];
        s1_outIsU32 = _RANDOM[4'h0][2];
        s1_outIsS32 = _RANDOM[4'h0][3];
        s1_outIsU64 = _RANDOM[4'h0][4];
        s1_outIsS64 = _RANDOM[4'h0][5];
        s1_fpCanonicalNAN = _RANDOM[4'h0][6];
        s2_outIsF64 = _RANDOM[4'h0][7];
        s2_fpCanonicalNAN = _RANDOM[4'h0][12];
        expIsOnesSrc = _RANDOM[4'h0][14];
        fracNotZeroSrc = _RANDOM[4'h0][15];
        isSubnormalSrc = _RANDOM[4'h0][18];
        isnormalSrc = _RANDOM[4'h0][19];
        isInfSrc = _RANDOM[4'h0][20];
        isZeroSrc = _RANDOM[4'h0][21];
        isNaNSrc = _RANDOM[4'h0][22];
        isSNaNSrc = _RANDOM[4'h0][23];
        isQNaNSrc = _RANDOM[4'h0][24];
        isNormalRec0 = _RANDOM[4'h0][25];
        isNormalRec1 = _RANDOM[4'h0][26];
        isNormalRec2 = _RANDOM[4'h0][27];
        isSubnormalRec0 = _RANDOM[4'h0][28];
        isSubnormalRec1 = _RANDOM[4'h0][29];
        isSubnormalRec2 = _RANDOM[4'h0][30];
        isRec = _RANDOM[4'h0][31];
        isInt2Fp = _RANDOM[4'h1][0];
        isFpWiden = _RANDOM[4'h1][1];
        isFpNarrow = _RANDOM[4'h1][2];
        isEstimate7 = _RANDOM[4'h1][3];
        isFp2Int = _RANDOM[4'h1][4];
        trunSticky = _RANDOM[4'h1][5];
        signSrc = _RANDOM[4'h1][6];
        rm = _RANDOM[4'h1][9:7];
        hasSignInt = _RANDOM[4'h1][10];
        isZeroIntSrc = _RANDOM[4'h1][11];
        output1HReg = _RANDOM[4'h1][15:12];
        fflags = _RANDOM[4'h1][20:16];
        result = {_RANDOM[4'h1][31:21], _RANDOM[4'h2], _RANDOM[4'h3][20:0]};
        expAdderIn0 = {_RANDOM[4'h3][31:21], _RANDOM[4'h4][1:0]};
        expAdderIn1 = _RANDOM[4'h4][14:2];
        expNormaled0 = _RANDOM[4'h4][15];
        inIsFp = _RANDOM[4'h4][16];
        fracSrcLeft = {_RANDOM[4'h4][31:17], _RANDOM[4'h5], _RANDOM[4'h6][16:0]};
        absIntSrc = {_RANDOM[4'h6][31:17], _RANDOM[4'h7], _RANDOM[4'h8][16:0]};
        leadZeros = _RANDOM[4'h8][23:17];
        shamtIn = {_RANDOM[4'h8][31:24], _RANDOM[4'h9], _RANDOM[4'hA][24:0]};
        shamt = {_RANDOM[4'hA][31:25], _RANDOM[4'hB][3:0]};
        s2_resultForfpCanonicalNAN =
          {_RANDOM[4'hB][31:4], _RANDOM[4'hC], _RANDOM[4'hD][3:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        fireReg_last_r = 1'h0;
        expIsOnesSrc = 1'h0;
        fracNotZeroSrc = 1'h0;
        isSubnormalSrc = 1'h0;
        isnormalSrc = 1'h0;
        isInfSrc = 1'h0;
        isZeroSrc = 1'h0;
        isNaNSrc = 1'h0;
        isSNaNSrc = 1'h0;
        isQNaNSrc = 1'h0;
        isNormalRec0 = 1'h0;
        isNormalRec1 = 1'h0;
        isNormalRec2 = 1'h0;
        isSubnormalRec0 = 1'h0;
        isSubnormalRec1 = 1'h0;
        isSubnormalRec2 = 1'h0;
        isRec = 1'h0;
        isInt2Fp = 1'h0;
        isFpWiden = 1'h0;
        isFpNarrow = 1'h0;
        isEstimate7 = 1'h0;
        isFp2Int = 1'h0;
        trunSticky = 1'h0;
        signSrc = 1'h0;
        rm = 3'h0;
        hasSignInt = 1'h0;
        isZeroIntSrc = 1'h0;
        output1HReg = 4'h0;
        fflags = 5'h0;
        result = 64'h0;
        expNormaled0 = 1'h0;
        inIsFp = 1'h0;
        fracSrcLeft = 64'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CLZ_4 leadZerosNext_clz (
    .io_in  (io_opType[7] ? fracSrcLeftNext : absIntSrcNext),
    .io_out (_leadZerosNext_clz_io_out)
  );
  ShiftRightJam shiftRightJam (
    .io_in     (shamtIn),
    .io_shamt  (shamt),
    .io_out    (_shiftRightJam_io_out),
    .io_sticky (_shiftRightJam_io_sticky)
  );
  RoundingUnit_2 rounder (
    .io_in       (rounderInput),
    .io_roundIn
      (isFp2Int
         ? _shiftRightJam_io_out[0]
         : output1HReg[1] & rounderMapIn[53] | output1HReg[2] & rounderMapIn[40]
           | output1HReg[3] & rounderMapIn[11]),
    .io_stickyIn
      (isFp2Int
         ? _shiftRightJam_io_sticky
         : output1HReg[1] & (|(rounderMapIn[52:0])) | output1HReg[2]
           & (|(rounderMapIn[39:0])) | output1HReg[3] & (|(rounderMapIn[10:0]))),
    .io_signIn   (signSrc),
    .io_rm       (rm),
    .io_inexact  (_rounder_io_inexact),
    .io_r_up     (_rounder_io_r_up)
  );
  RoundingUnit_3 subRounder (
    .io_in       (subRounderInput),
    .io_roundIn
      (output1HReg[1] & _shiftRightJam_io_out[53] | output1HReg[2]
       & _shiftRightJam_io_out[40]),
    .io_stickyIn
      (output1HReg[1] & (_subRounderMap_T_9 | (|(_shiftRightJam_io_out[52:0])))
       | output1HReg[2] & (_subRounderMap_T_9 | (|(_shiftRightJam_io_out[39:0])))),
    .io_signIn   (signSrc),
    .io_rm       (rm),
    .io_inexact  (_subRounder_io_inexact),
    .io_r_up     (_subRounder_io_r_up)
  );
  Rsqrt7Table rsqrt7Table (
    .src ({expNormaled0, fracNormaled[51:46]}),
    .out (_rsqrt7Table_out)
  );
  Rec7Table rec7Table (
    .src (fracNormaled[51:45]),
    .out (_rec7Table_out)
  );
  assign io_result = s2_fpCanonicalNAN ? s2_resultForfpCanonicalNAN : result;
  assign io_fflags = s2_fpCanonicalNAN & ~s2_outIsF64 ? 5'h10 : fflags;
endmodule

