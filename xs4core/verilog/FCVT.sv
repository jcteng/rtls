// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module FCVT(
  input         clock,
  input         reset,
  input         io_flush_valid,
  input         io_flush_bits_robIdx_flag,
  input  [7:0]  io_flush_bits_robIdx_value,
  input         io_flush_bits_level,
  input         io_in_valid,
  input  [8:0]  io_in_bits_ctrl_fuOpType,
  input         io_in_bits_ctrl_robIdx_flag,
  input  [7:0]  io_in_bits_ctrl_robIdx_value,
  input  [7:0]  io_in_bits_ctrl_pdest,
  input         io_in_bits_ctrl_rfWen,
  input         io_in_bits_ctrl_fpWen,
  input         io_in_bits_ctrl_fpu_wflags,
  input  [2:0]  io_in_bits_ctrl_fpu_rm,
  input  [1:0]  io_in_bits_ctrl_vpu_vsew,
  input  [63:0] io_in_bits_data_src_0,
  output        io_out_valid,
  output        io_out_bits_ctrl_robIdx_flag,
  output [7:0]  io_out_bits_ctrl_robIdx_value,
  output [7:0]  io_out_bits_ctrl_pdest,
  output        io_out_bits_ctrl_rfWen,
  output        io_out_bits_ctrl_fpWen,
  output        io_out_bits_ctrl_fpu_wflags,
  output [63:0] io_out_bits_res_data,
  output [4:0]  io_out_bits_res_fflags,
  input  [2:0]  io_frm
);

  wire [63:0] _fcvt_io_result;
  wire [19:0] _fcvt_io_fflags;
  reg         validVec_1;
  reg         validVec_2;
  reg  [8:0]  ctrlVec_1_fuOpType;
  reg         ctrlVec_1_robIdx_flag;
  reg  [7:0]  ctrlVec_1_robIdx_value;
  reg  [7:0]  ctrlVec_1_pdest;
  reg         ctrlVec_1_rfWen;
  reg         ctrlVec_1_fpWen;
  reg         ctrlVec_1_fpu_wflags;
  reg  [8:0]  ctrlVec_2_fuOpType;
  reg         ctrlVec_2_robIdx_flag;
  reg  [7:0]  ctrlVec_2_robIdx_value;
  reg  [7:0]  ctrlVec_2_pdest;
  reg         ctrlVec_2_rfWen;
  reg         ctrlVec_2_fpWen;
  reg         ctrlVec_2_fpu_wflags;
  wire [8:0]  _fixflushVec_flushItself_T_2 =
    {io_flush_bits_robIdx_flag, io_flush_bits_robIdx_value};
  wire        _GEN =
    io_in_valid
    & ~(io_in_valid & io_flush_valid
        & (io_flush_bits_level
           & {io_in_bits_ctrl_robIdx_flag,
              io_in_bits_ctrl_robIdx_value} == _fixflushVec_flushItself_T_2
           | io_in_bits_ctrl_robIdx_flag ^ io_flush_bits_robIdx_flag
           ^ io_in_bits_ctrl_robIdx_value > io_flush_bits_robIdx_value));
  wire        _GEN_0 =
    validVec_1
    & ~(validVec_1 & io_flush_valid
        & (io_flush_bits_level
           & {ctrlVec_1_robIdx_flag,
              ctrlVec_1_robIdx_value} == _fixflushVec_flushItself_T_2
           | ctrlVec_1_robIdx_flag ^ io_flush_bits_robIdx_flag
           ^ ctrlVec_1_robIdx_value > io_flush_bits_robIdx_value));
  wire        isRtz = io_in_bits_ctrl_fuOpType[2] & io_in_bits_ctrl_fuOpType[1];
  wire        isRod =
    io_in_bits_ctrl_fuOpType[2] & ~(io_in_bits_ctrl_fuOpType[1])
    & io_in_bits_ctrl_fuOpType[0];
  reg         fireReg_last_r;
  reg         outIs16bits_REG;
  reg         outIs16bits;
  reg         outIs32bits_REG;
  reg         outIs32bits;
  reg         isNarrowCycle2_r;
  reg         isNarrowCycle2;
  reg  [3:0]  outputWidth1HCycle2_r;
  reg  [3:0]  outputWidth1HCycle2;
  wire [63:0] fcvtResult =
    isNarrowCycle2 ? {32'h0, _fcvt_io_result[31:0]} : _fcvt_io_result;
  reg  [63:0] result_REG;
  reg  [63:0] result_REG_1;
  wire [63:0] result =
    ctrlVec_2_fuOpType[8]
      ? result_REG_1
      : outIs32bits & ctrlVec_2_fuOpType[6]
          ? {32'hFFFFFFFF, fcvtResult[31:0]}
          : outIs16bits & ctrlVec_2_fuOpType[6]
              ? {48'hFFFFFFFFFFFF, fcvtResult[15:0]}
              : fcvtResult;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      validVec_1 <= 1'h0;
      validVec_2 <= 1'h0;
      fireReg_last_r <= 1'h0;
    end
    else begin
      validVec_1 <= _GEN & io_in_valid;
      validVec_2 <= _GEN_0 & validVec_1;
      if (io_in_valid | fireReg_last_r)
        fireReg_last_r <= io_in_valid;
    end
  end // always @(posedge, posedge)
  wire [3:0]  output1H_invInputs =
    ~{io_in_bits_ctrl_fuOpType[4:3], io_in_bits_ctrl_vpu_vsew};
  wire [1:0]  _output1H_orMatrixOutputs_T_1 =
    {&{io_in_bits_ctrl_vpu_vsew[0], output1H_invInputs[1], output1H_invInputs[2]},
     &{output1H_invInputs[0],
       output1H_invInputs[1],
       io_in_bits_ctrl_fuOpType[3],
       output1H_invInputs[3]}};
  wire [1:0]  _output1H_orMatrixOutputs_T_3 =
    {&{output1H_invInputs[0], io_in_bits_ctrl_vpu_vsew[1], output1H_invInputs[2]},
     &{io_in_bits_ctrl_vpu_vsew[0],
       output1H_invInputs[1],
       io_in_bits_ctrl_fuOpType[3],
       output1H_invInputs[3]}};
  always @(posedge clock) begin
    if (_GEN) begin
      ctrlVec_1_fuOpType <= io_in_bits_ctrl_fuOpType;
      ctrlVec_1_robIdx_flag <= io_in_bits_ctrl_robIdx_flag;
      ctrlVec_1_robIdx_value <= io_in_bits_ctrl_robIdx_value;
      ctrlVec_1_pdest <= io_in_bits_ctrl_pdest;
      ctrlVec_1_rfWen <= io_in_bits_ctrl_rfWen;
      ctrlVec_1_fpWen <= io_in_bits_ctrl_fpWen;
      ctrlVec_1_fpu_wflags <= io_in_bits_ctrl_fpu_wflags;
    end
    if (_GEN_0) begin
      ctrlVec_2_fuOpType <= ctrlVec_1_fuOpType;
      ctrlVec_2_robIdx_flag <= ctrlVec_1_robIdx_flag;
      ctrlVec_2_robIdx_value <= ctrlVec_1_robIdx_value;
      ctrlVec_2_pdest <= ctrlVec_1_pdest;
      ctrlVec_2_rfWen <= ctrlVec_1_rfWen;
      ctrlVec_2_fpWen <= ctrlVec_1_fpWen;
      ctrlVec_2_fpu_wflags <= ctrlVec_1_fpu_wflags;
    end
    outIs16bits_REG <= |_output1H_orMatrixOutputs_T_1;
    outIs16bits <= outIs16bits_REG;
    outIs32bits_REG <= |_output1H_orMatrixOutputs_T_3;
    outIs32bits <= outIs32bits_REG;
    if (io_in_valid) begin
      isNarrowCycle2_r <= io_in_bits_ctrl_fuOpType[4] & ~(io_in_bits_ctrl_fuOpType[3]);
      outputWidth1HCycle2_r <=
        {|{&{io_in_bits_ctrl_vpu_vsew[0],
             io_in_bits_ctrl_vpu_vsew[1],
             output1H_invInputs[2],
             output1H_invInputs[3]},
           &{output1H_invInputs[0],
             io_in_bits_ctrl_vpu_vsew[1],
             io_in_bits_ctrl_fuOpType[3],
             output1H_invInputs[3]}},
         |_output1H_orMatrixOutputs_T_3,
         |_output1H_orMatrixOutputs_T_1,
         &{output1H_invInputs[0],
           output1H_invInputs[1],
           output1H_invInputs[2],
           io_in_bits_ctrl_fuOpType[4]}};
    end
    if (fireReg_last_r) begin
      isNarrowCycle2 <= isNarrowCycle2_r;
      outputWidth1HCycle2 <= outputWidth1HCycle2_r;
    end
    result_REG <= io_in_bits_data_src_0;
    result_REG_1 <= result_REG;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:63];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [6:0] i = 7'h0; i < 7'h40; i += 7'h1) begin
          _RANDOM[i[5:0]] = `RANDOM;
        end
        validVec_1 = _RANDOM[6'h0][0];
        validVec_2 = _RANDOM[6'h0][1];
        ctrlVec_1_fuOpType = _RANDOM[6'h0][10:2];
        ctrlVec_1_robIdx_flag = _RANDOM[6'h0][11];
        ctrlVec_1_robIdx_value = _RANDOM[6'h0][19:12];
        ctrlVec_1_pdest = _RANDOM[6'h0][27:20];
        ctrlVec_1_rfWen = _RANDOM[6'h0][28];
        ctrlVec_1_fpWen = _RANDOM[6'h0][29];
        ctrlVec_1_fpu_wflags = _RANDOM[6'h1][2];
        ctrlVec_2_fuOpType = _RANDOM[6'h7][27:19];
        ctrlVec_2_robIdx_flag = _RANDOM[6'h7][28];
        ctrlVec_2_robIdx_value = {_RANDOM[6'h7][31:29], _RANDOM[6'h8][4:0]};
        ctrlVec_2_pdest = _RANDOM[6'h8][12:5];
        ctrlVec_2_rfWen = _RANDOM[6'h8][13];
        ctrlVec_2_fpWen = _RANDOM[6'h8][14];
        ctrlVec_2_fpu_wflags = _RANDOM[6'h8][19];
        fireReg_last_r = _RANDOM[6'h3B][6];
        outIs16bits_REG = _RANDOM[6'h3B][7];
        outIs16bits = _RANDOM[6'h3B][8];
        outIs32bits_REG = _RANDOM[6'h3B][9];
        outIs32bits = _RANDOM[6'h3B][10];
        isNarrowCycle2_r = _RANDOM[6'h3B][11];
        isNarrowCycle2 = _RANDOM[6'h3B][12];
        outputWidth1HCycle2_r = _RANDOM[6'h3B][16:13];
        outputWidth1HCycle2 = _RANDOM[6'h3B][20:17];
        result_REG = {_RANDOM[6'h3B][31:21], _RANDOM[6'h3C], _RANDOM[6'h3D][20:0]};
        result_REG_1 = {_RANDOM[6'h3D][31:21], _RANDOM[6'h3E], _RANDOM[6'h3F][20:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        validVec_1 = 1'h0;
        validVec_2 = 1'h0;
        fireReg_last_r = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  VectorCvt fcvt (
    .clock            (clock),
    .reset            (reset),
    .io_fire          (io_in_valid),
    .io_src           (io_in_bits_data_src_0),
    .io_opType        (io_in_bits_ctrl_fuOpType[7:0]),
    .io_sew           (io_in_bits_ctrl_vpu_vsew),
    .io_rm
      ({2'h0, isRtz} | (isRod ? 3'h6 : 3'h0)
       | (isRtz | isRod
            ? 3'h0
            : io_in_bits_ctrl_fpu_rm != 3'h7 ? io_in_bits_ctrl_fpu_rm : io_frm)),
    .io_isFpToVecInst (1'h1),
    .io_result        (_fcvt_io_result),
    .io_fflags        (_fcvt_io_fflags)
  );
  assign io_out_valid = validVec_2;
  assign io_out_bits_ctrl_robIdx_flag = ctrlVec_2_robIdx_flag;
  assign io_out_bits_ctrl_robIdx_value = ctrlVec_2_robIdx_value;
  assign io_out_bits_ctrl_pdest = ctrlVec_2_pdest;
  assign io_out_bits_ctrl_rfWen = ctrlVec_2_rfWen;
  assign io_out_bits_ctrl_fpWen = ctrlVec_2_fpWen;
  assign io_out_bits_ctrl_fpu_wflags = ctrlVec_2_fpu_wflags;
  assign io_out_bits_res_data =
    outIs32bits & ~(ctrlVec_2_fuOpType[6]) ? {{32{result[31]}}, result[31:0]} : result;
  assign io_out_bits_res_fflags =
    ctrlVec_2_fuOpType[8]
      ? 5'h0
      : (outputWidth1HCycle2[0] ? _fcvt_io_fflags[4:0] : 5'h0)
        | (outputWidth1HCycle2[1] ? _fcvt_io_fflags[4:0] : 5'h0)
        | (outputWidth1HCycle2[2]
             ? (isNarrowCycle2 ? _fcvt_io_fflags[4:0] : _fcvt_io_fflags[4:0])
             : 5'h0) | (outputWidth1HCycle2[3] ? _fcvt_io_fflags[4:0] : 5'h0);
endmodule

