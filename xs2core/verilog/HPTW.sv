// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module HPTW(
  input         clock,
  input         reset,
  input         io_sfence_valid,
  input         io_csr_satp_changed,
  input         io_csr_vsatp_changed,
  input  [15:0] io_csr_hgatp_asid,
  input  [43:0] io_csr_hgatp_ppn,
  input         io_csr_hgatp_changed,
  output        io_req_ready,
  input         io_req_valid,
  input  [1:0]  io_req_bits_source,
  input  [2:0]  io_req_bits_id,
  input  [28:0] io_req_bits_gvpn,
  input  [23:0] io_req_bits_ppn,
  input         io_req_bits_l1Hit,
  input         io_req_bits_l2Hit,
  input         io_req_bits_bypassed,
  input         io_resp_ready,
  output        io_resp_valid,
  output [28:0] io_resp_bits_resp_entry_tag,
  output [13:0] io_resp_bits_resp_entry_vmid,
  output [23:0] io_resp_bits_resp_entry_ppn,
  output        io_resp_bits_resp_entry_perm_d,
  output        io_resp_bits_resp_entry_perm_a,
  output        io_resp_bits_resp_entry_perm_g,
  output        io_resp_bits_resp_entry_perm_u,
  output        io_resp_bits_resp_entry_perm_x,
  output        io_resp_bits_resp_entry_perm_w,
  output        io_resp_bits_resp_entry_perm_r,
  output [1:0]  io_resp_bits_resp_entry_level,
  output        io_resp_bits_resp_gpf,
  output        io_resp_bits_resp_gaf,
  output [2:0]  io_resp_bits_id,
  input         io_mem_req_ready,
  output        io_mem_req_valid,
  output [35:0] io_mem_req_bits_addr,
  output        io_mem_req_bits_hptw_bypassed,
  input         io_mem_resp_valid,
  input  [63:0] io_mem_resp_bits,
  input         io_mem_mask,
  output [28:0] io_refill_req_info_vpn,
  output [1:0]  io_refill_req_info_source,
  output [1:0]  io_refill_level,
  output [35:0] io_pmp_req_bits_addr,
  input         io_pmp_resp_ld,
  input         io_pmp_resp_mmio
);

  wire        finish;
  wire        flush =
    io_sfence_valid | io_csr_hgatp_changed | io_csr_satp_changed | io_csr_vsatp_changed;
  reg  [1:0]  level;
  reg  [40:0] gpaddr;
  reg  [23:0] req_ppn;
  reg         l1Hit;
  reg         l2Hit;
  reg         bypassed;
  wire        _pageFault_T_7 = level == 2'h1;
  wire [1:0]  _p_pte_T = 2'(2'h2 - level);
  wire        _pageFault_T_12 = level == 2'h0;
  wire [35:0] mem_addr =
    _pageFault_T_12
      ? 36'({io_csr_hgatp_ppn[23:0], 12'h0} + {22'h0, gpaddr[40:30], 3'h0})
      : {(_pageFault_T_7 ? l1Hit : l2Hit) ? req_ppn : io_mem_resp_bits[33:10],
         _p_pte_T == 2'h0
           ? gpaddr[20:12]
           : _p_pte_T == 2'h1 ? gpaddr[29:21] : gpaddr[38:30],
         3'h0};
  reg         s_pmp_check;
  reg         s_mem_req;
  reg         w_mem_resp;
  reg         idle;
  reg         mem_addr_update;
  wire        sent_to_pmp = ~idle & (~s_pmp_check | mem_addr_update) & ~finish;
  wire        _find_pte_T = io_mem_resp_bits[1] | io_mem_resp_bits[3];
  wire        pageFault =
    ~(io_mem_resp_bits[0]) | ~(io_mem_resp_bits[1]) & io_mem_resp_bits[2]
    | (_find_pte_T | io_mem_resp_bits[2])
    & ~(level == 2'h2 | _pageFault_T_7 & io_mem_resp_bits[18:10] == 9'h0 | _pageFault_T_12
        & io_mem_resp_bits[27:10] == 18'h0) | ~(_find_pte_T | io_mem_resp_bits[2])
    & level[1];
  reg         accessFault;
  wire        find_pte =
    _find_pte_T | io_mem_resp_bits[2] | (|(io_mem_resp_bits[53:34])) | pageFault;
  wire        resp_valid =
    ~idle & mem_addr_update & (w_mem_resp & find_pte | s_pmp_check & accessFault);
  reg  [2:0]  id;
  wire        _source_T = idle & io_req_valid;
  reg  [1:0]  source;
  wire        resp_gaf = accessFault | (|(io_mem_resp_bits[53:34]));
  wire        io_mem_req_valid_0 = ~s_mem_req & ~io_mem_mask & ~accessFault & s_pmp_check;
  wire        _GEN = idle & _source_T;
  wire        _GEN_0 = find_pte | accessFault;
  wire        _GEN_1 = io_resp_ready & resp_valid;
  assign finish = mem_addr_update & _GEN_0 & resp_valid;
  wire        _GEN_2 = sent_to_pmp & ~mem_addr_update;
  wire        _GEN_3 = accessFault & ~idle;
  wire        _GEN_4 = io_mem_req_ready & io_mem_req_valid_0;
  wire        _GEN_5 = io_mem_resp_valid & ~w_mem_resp;
  wire        _GEN_6 = mem_addr_update & ~_GEN_0;
  wire        _GEN_7 = resp_valid & _GEN_1;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      level <= 2'h0;
      s_pmp_check <= 1'h1;
      s_mem_req <= 1'h1;
      w_mem_resp <= 1'h1;
      idle <= 1'h1;
      mem_addr_update <= 1'h0;
    end
    else begin
      if (_GEN_6)
        level <= 2'(level + 2'h1);
      else if (_GEN)
        level <= io_req_bits_l2Hit ? 2'h2 : {1'h0, io_req_bits_l1Hit};
      s_pmp_check <= flush | _GEN_3 | _GEN_2 | ~_GEN & s_pmp_check;
      s_mem_req <= flush | ~_GEN_6 & (_GEN_4 | _GEN_3 | ~_GEN_2 & s_mem_req);
      w_mem_resp <= flush | _GEN_5 | ~_GEN_4 & (_GEN_3 | w_mem_resp);
      idle <= flush | mem_addr_update & _GEN_0 & _GEN_7 | ~_GEN & idle;
      mem_addr_update <=
        ~(flush | mem_addr_update & (~_GEN_0 | _GEN_7))
        & (_GEN_5 | _GEN_3 | mem_addr_update);
    end
  end // always @(posedge, posedge)
  wire        _GEN_8 = sent_to_pmp ? io_pmp_resp_ld | io_pmp_resp_mmio : accessFault;
  always @(posedge clock) begin
    if (_GEN) begin
      gpaddr <= {io_req_bits_gvpn, 12'h0};
      req_ppn <= io_req_bits_ppn;
      l1Hit <= io_req_bits_l1Hit;
      l2Hit <= io_req_bits_l2Hit;
      bypassed <= io_req_bits_bypassed;
      id <= io_req_bits_id;
    end
    accessFault <=
      ~flush
      & (mem_addr_update & _GEN_0 & resp_valid
           ? ~(_GEN_1 | _GEN) & _GEN_8
           : ~_GEN & _GEN_8);
    if (_source_T)
      source <= io_req_bits_source;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:2];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        level = _RANDOM[2'h0][1:0];
        gpaddr = {_RANDOM[2'h0][31:2], _RANDOM[2'h1][10:0]};
        req_ppn = {_RANDOM[2'h1][31:11], _RANDOM[2'h2][2:0]};
        l1Hit = _RANDOM[2'h2][3];
        l2Hit = _RANDOM[2'h2][4];
        bypassed = _RANDOM[2'h2][5];
        s_pmp_check = _RANDOM[2'h2][6];
        s_mem_req = _RANDOM[2'h2][7];
        w_mem_resp = _RANDOM[2'h2][8];
        idle = _RANDOM[2'h2][9];
        mem_addr_update = _RANDOM[2'h2][10];
        accessFault = _RANDOM[2'h2][11];
        id = _RANDOM[2'h2][14:12];
        source = _RANDOM[2'h2][16:15];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        level = 2'h0;
        s_pmp_check = 1'h1;
        s_mem_req = 1'h1;
        w_mem_resp = 1'h1;
        idle = 1'h1;
        mem_addr_update = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_req_ready = idle;
  assign io_resp_valid = resp_valid;
  assign io_resp_bits_resp_entry_tag = gpaddr[40:12];
  assign io_resp_bits_resp_entry_vmid = io_csr_hgatp_asid[13:0];
  assign io_resp_bits_resp_entry_ppn = resp_gaf ? 24'h0 : io_mem_resp_bits[33:10];
  assign io_resp_bits_resp_entry_perm_d = ~resp_gaf & io_mem_resp_bits[7];
  assign io_resp_bits_resp_entry_perm_a = ~resp_gaf & io_mem_resp_bits[6];
  assign io_resp_bits_resp_entry_perm_g = ~resp_gaf & io_mem_resp_bits[5];
  assign io_resp_bits_resp_entry_perm_u = ~resp_gaf & io_mem_resp_bits[4];
  assign io_resp_bits_resp_entry_perm_x = ~resp_gaf & io_mem_resp_bits[3];
  assign io_resp_bits_resp_entry_perm_w = ~resp_gaf & io_mem_resp_bits[2];
  assign io_resp_bits_resp_entry_perm_r = ~resp_gaf & io_mem_resp_bits[1];
  assign io_resp_bits_resp_entry_level = level;
  assign io_resp_bits_resp_gpf = pageFault & ~accessFault & ~(|(io_mem_resp_bits[53:34]));
  assign io_resp_bits_resp_gaf = resp_gaf;
  assign io_resp_bits_id = id;
  assign io_mem_req_valid = io_mem_req_valid_0;
  assign io_mem_req_bits_addr = mem_addr;
  assign io_mem_req_bits_hptw_bypassed = bypassed;
  assign io_refill_req_info_vpn = gpaddr[40:12];
  assign io_refill_req_info_source = source;
  assign io_refill_level = level;
  assign io_pmp_req_bits_addr = mem_addr;
endmodule

